# Архитектура проекта и исправления

## Обзор архитектуры

### Frontend (React + TypeScript)
- **Framework**: Vite + React 18 + TypeScript
- **UI**: Tailwind CSS + shadcn/ui компоненты
- **Routing**: React Router v6
- **State Management**: Context API (AuthContext)
- **API клиент**: custom-backend.ts с автоматическим refresh токенов

### Backend (Go + Fiber)
- **Framework**: Fiber v2 (высокопроизводительный веб-фреймворк)
- **Database**: PostgreSQL с GORM ORM
- **Authentication**: JWT токены (access + refresh)
- **Cache**: Redis для кеширования
- **Storage**: Локальное хранилище для медиафайлов

## Структура базы данных

### Основная логика постов и комментариев
```sql
-- Таблица posts хранит И посты И комментарии
CREATE TABLE posts (
    id UUID PRIMARY KEY,
    user_id UUID REFERENCES users(id),
    content TEXT,
    reply_to_id UUID REFERENCES posts(id), -- NULL = пост, NOT NULL = комментарий
    root_post_id UUID REFERENCES posts(id), -- для вложенных комментариев
    -- другие поля...
);
```

**Ключевое**: Комментарии - это посты с заполненным `reply_to_id`. Это позволяет:
- Единую систему лайков/репостов для постов и комментариев
- Вложенные комментарии (ответы на комментарии)
- Простую структуру БД

## Исправленные проблемы

### 1. Комментарии отображались как посты в ленте

**Причина**: Timeline endpoints не фильтровали комментарии
**Решение**: Добавлен фильтр `WHERE reply_to_id IS NULL` во все timeline запросы:

```go
// custom-backend/internal/api/timeline.go
query = query.Where("reply_to_id IS NULL") // Исключаем комментарии из лент
```

Исправлены endpoints:
- `/timeline/home` - домашняя лента
- `/timeline/explore` - публичная лента  
- `/timeline/trending` - трендовые посты
- `/timeline/user/:id` - посты пользователя
- `/timeline/search` - поиск по метаданным

### 2. Проблема с комментированием чужих постов

**Анализ**: В backend коде НЕТ ограничений на создание комментариев к чужим постам.

```go
// custom-backend/internal/api/posts.go - CreatePost
if req.ReplyToID != nil && *req.ReplyToID != "" {
    // Любой авторизованный пользователь может создать комментарий
    post.ReplyToID = &replyToID
    // ...создание уведомления для автора поста
}
```

**Возможные причины на frontend**:
1. UI условно скрывает форму комментария
2. Ошибка при отправке запроса
3. Неправильная обработка ответа от сервера

## Как работает система

### Создание поста/комментария
1. **Frontend**: Отправляет POST запрос на `/api/posts/` с данными:
   ```json
   {
     "content": "Текст",
     "reply_to_id": "uuid-поста", // если это комментарий
     "metadata": {...}
   }
   ```

2. **Backend**: 
   - Санитизирует контент
   - Если есть `reply_to_id` - это комментарий
   - Увеличивает счетчик `replies_count` у родительского поста
   - Создает уведомление для автора оригинального поста

3. **Frontend**: Обновляет UI с новым комментарием

### Загрузка комментариев
1. **Frontend**: GET запрос на `/api/posts/:id/replies`
2. **Backend**: Возвращает ВСЕ комментарии ветки (включая вложенные)
3. **Frontend**: Строит дерево комментариев для отображения

## Рекомендации для дальнейшей отладки

### Проверка проблемы с комментированием

1. **Откройте DevTools** и попробуйте прокомментировать чужой пост
2. **Проверьте Network вкладку**:
   - Отправляется ли POST запрос на `/api/posts/`?
   - Какой ответ от сервера?
   - Есть ли ошибки?

3. **Проверьте Console**:
   - Есть ли JavaScript ошибки?
   - Что логирует приложение?

4. **Проверьте условия в коде**:
   - В `UnifiedPostDetail.tsx` форма комментария показывается если есть `user`
   - Возможно есть другие условия в родительских компонентах?

## Технологический стек

### Frontend зависимости
- react: 18.x
- react-router-dom: 6.x
- @tanstack/react-query: для кеширования данных
- tailwindcss: для стилей
- @radix-ui/*: базовые UI компоненты
- lucide-react: иконки

### Backend зависимости
- fiber: v2 - веб фреймворк
- gorm: ORM для работы с БД
- jwt: для аутентификации
- bcrypt: хеширование паролей
- uuid: генерация ID
- redis: кеширование

### Инфраструктура
- PostgreSQL: основная БД
- Redis: кеш и сессии
- Nginx: реверс-прокси (production)
- Railway/Netlify: хостинг

## Архитектурные особенности

1. **Единая таблица для постов и комментариев** - упрощает структуру и логику
2. **JWT с refresh токенами** - безопасная аутентификация
3. **JSONB для метаданных** - гибкое хранение дополнительных данных
4. **Санитизация на backend** - безопасность от XSS
5. **Транзакции для критичных операций** - целостность данных
6. **Middleware для проверки прав** - централизованная авторизация

## Для передачи другой нейросети

Этот документ содержит полную информацию об архитектуре. При возникновении проблем:
1. Проверяйте Network вкладку в DevTools
2. Смотрите логи backend (если есть доступ)
3. Проверяйте, что токены валидны
4. Убедитесь, что все миграции БД применены

Backend API документирован в коде, основные endpoints:
- `/api/auth/*` - аутентификация
- `/api/users/*` - пользователи
- `/api/posts/*` - посты и комментарии
- `/api/timeline/*` - ленты
- `/api/notifications/*` - уведомления
