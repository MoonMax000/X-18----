// Social Media Models Extension for Tyrian Trade
// Add these models to your main schema.prisma file

// ============================================
// SOCIAL MEDIA / GOTOSOCIAL MODELS
// ============================================

model Post {
  id              String   @id @default(uuid())
  authorId        String   @map("author_id")
  author          User     @relation("UserPosts", fields: [authorId], references: [id], onDelete: Cascade)
  
  // Content
  content         String   @db.Text
  contentHtml     String?  @map("content_html") @db.Text
  
  // Reply/Thread
  inReplyToId     String?  @map("in_reply_to_id")
  inReplyTo       Post?    @relation("PostReplies", fields: [inReplyToId], references: [id], onDelete: SetNull)
  replies         Post[]   @relation("PostReplies")
  
  // Visibility
  visibility      String   @default("public") // public, unlisted, private, direct
  
  // Content warnings
  sensitive       Boolean  @default(false)
  spoilerText     String?  @map("spoiler_text")
  
  // Metadata
  language        String?
  tags            String[] // Hashtags
  mentions        String[] // @username mentions
  
  // Counts
  repliesCount    Int      @default(0) @map("replies_count")
  reblogsCount    Int      @default(0) @map("reblogs_count")
  favouritesCount Int      @default(0) @map("favourites_count")
  
  // Custom metadata for trading signals
  customMetadata  Json?    @map("custom_metadata")
  
  // Monetization
  accessLevel     String   @default("free") @map("access_level") // free, paid, subscribers, premium
  price           Decimal? @db.Decimal(10, 2)
  
  // Status
  isDeleted       Boolean  @default(false) @map("is_deleted")
  isPinned        Boolean  @default(false) @map("is_pinned")
  editedAt        DateTime? @map("edited_at")
  
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")
  
  // Relations
  media           MediaAttachment[]
  favourites      Favourite[]
  reblogs         Reblog[]
  bookmarks       Bookmark[]
  
  @@index([authorId])
  @@index([createdAt])
  @@index([visibility])
  @@map("posts")
}

model MediaAttachment {
  id          String   @id @default(uuid())
  postId      String   @map("post_id")
  post        Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  
  // File info
  type        String   // image, video, gifv, audio
  url         String
  previewUrl  String?  @map("preview_url")
  remoteUrl   String?  @map("remote_url")
  
  // Metadata
  description String?  @db.Text // Alt text
  blurhash    String?
  meta        Json?    // dimensions, duration, etc.
  
  createdAt   DateTime @default(now()) @map("created_at")
  
  @@index([postId])
  @@map("media_attachments")
}

model Favourite {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  user      User     @relation("UserFavourites", fields: [userId], references: [id], onDelete: Cascade)
  postId    String   @map("post_id")
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now()) @map("created_at")
  
  @@unique([userId, postId])
  @@index([userId])
  @@index([postId])
  @@map("favourites")
}

model Reblog {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  user      User     @relation("UserReblogs", fields: [userId], references: [id], onDelete: Cascade)
  postId    String   @map("post_id")
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  
  visibility String  @default("public")
  
  createdAt DateTime @default(now()) @map("created_at")
  
  @@unique([userId, postId])
  @@index([userId])
  @@index([postId])
  @@map("reblogs")
}

model Bookmark {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  user      User     @relation("UserBookmarks", fields: [userId], references: [id], onDelete: Cascade)
  postId    String   @map("post_id")
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now()) @map("created_at")
  
  @@unique([userId, postId])
  @@index([userId])
  @@index([postId])
  @@map("bookmarks")
}

model Follow {
  id          String   @id @default(uuid())
  followerId  String   @map("follower_id")
  follower    User     @relation("Following", fields: [followerId], references: [id], onDelete: Cascade)
  followingId String   @map("following_id")
  following   User     @relation("Followers", fields: [followingId], references: [id], onDelete: Cascade)
  
  // Status
  isApproved  Boolean  @default(true) @map("is_approved") // For private accounts
  
  createdAt   DateTime @default(now()) @map("created_at")
  
  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@map("follows")
}

model Notification {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  user      User     @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)
  
  // Notification type
  type      String   // mention, status, reblog, follow, favourite, poll, update
  
  // Related entities
  fromUserId String? @map("from_user_id")
  fromUser   User?   @relation("NotificationsFrom", fields: [fromUserId], references: [id], onDelete: SetNull)
  postId     String? @map("post_id")
  
  // Status
  isRead    Boolean  @default(false) @map("is_read")
  
  createdAt DateTime @default(now()) @map("created_at")
  
  @@index([userId])
  @@index([isRead])
  @@index([createdAt])
  @@map("notifications")
}

// Add these relations to the User model:
// posts                Post[]         @relation("UserPosts")
// favourites           Favourite[]    @relation("UserFavourites")
// reblogs              Reblog[]       @relation("UserReblogs")
// bookmarks            Bookmark[]     @relation("UserBookmarks")
// followers            Follow[]       @relation("Followers")
// following            Follow[]       @relation("Following")
// notifications        Notification[] @relation("UserNotifications")
// notificationsFrom    Notification[] @relation("NotificationsFrom")
