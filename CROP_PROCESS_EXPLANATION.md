# Процесс обрезки изображений - Детальное объяснение

## Важно! Два разных изображения:

### 1. Превью (для показа пользователю) - НЕ отправляется на сервер
### 2. Финальное изображение - создается на сервере

---

## Полный процесс шаг за шагом:

```
┌─────────────────────────────────────────────────────────────────┐
│ ШАГ 1: ЗАГРУЗКА ИЗОБРАЖЕНИЯ                                     │
└─────────────────────────────────────────────────────────────────┘

Пользователь выбирает файл
         ↓
Файл загружается на сервер (ОРИГИНАЛ)
         ↓
Сервер сохраняет ОРИГИНАЛ в storage
         ↓
Возвращает URL оригинального изображения
         ↓
Клиент показывает оригинал в окне создания поста


┌─────────────────────────────────────────────────────────────────┐
│ ШАГ 2: ОБРЕЗКА (редактирование)                                │
└─────────────────────────────────────────────────────────────────┘

Пользователь нажимает "Edit"
         ↓
Открывается редактор обрезки
         ↓
Пользователь выбирает область обрезки
         ↓
react-easy-crop определяет координаты:
  - x: 100 (пиксели от левого края)
  - y: 50 (пиксели от верхнего края)
  - width: 800 (ширина области)
  - height: 600 (высота области)
         ↓
Пользователь нажимает "Save"


┌─────────────────────────────────────────────────────────────────┐
│ ШАГ 3: СОЗДАНИЕ ПРЕВЬЮ (только для показа!)                    │
└─────────────────────────────────────────────────────────────────┘

Canvas API создает обрезанное изображение:
  - Берет ОРИГИНАЛ
  - Вырезает область (x:100, y:50, w:800, h:600)
  - Создает blob URL: blob:http://localhost:3000/abc-123
         ↓
Blob URL сохраняется ТОЛЬКО в памяти браузера
         ↓
MediaGrid показывает это превью пользователю
         ↓
⚠️ Это превью НИКОГДА не отправляется на сервер!
⚠️ Это только для показа пользователю!


┌─────────────────────────────────────────────────────────────────┐
│ ШАГ 4: ПУБЛИКАЦИЯ ПОСТА                                         │
└─────────────────────────────────────────────────────────────────┘

Пользователь нажимает "Post"
         ↓
На сервер отправляется:
  ✅ URL оригинального изображения
  ✅ Координаты обрезки: {x:100, y:50, w:800, h:600}
  ❌ НЕ blob URL превью (он остается в браузере)
         ↓
Сервер получает запрос на создание поста


┌─────────────────────────────────────────────────────────────────┐
│ ШАГ 5: ОБРАБОТКА НА СЕРВЕРЕ                                    │
└─────────────────────────────────────────────────────────────────┘

Сервер:
  1. Берет ОРИГИНАЛЬНОЕ изображение из storage
  2. Читает координаты обрезки {x:100, y:50, w:800, h:600}
  3. Обрезает изображение используя эти координаты
  4. Сохраняет ОБРЕЗАННОЕ изображение как финальное
  5. Удаляет оригинал (если нужно)
  6. Сохраняет пост в БД с URL обрезанного изображения
         ↓
Пост опубликован!


┌─────────────────────────────────────────────────────────────────┐
│ ШАГ 6: ОТОБРАЖЕНИЕ В ЛЕНТЕ                                     │
└─────────────────────────────────────────────────────────────────┘

Другие пользователи видят пост:
  - Изображение уже обрезано сервером
  - Показывается финальное обрезанное изображение
  - Это НЕ то превью, которое создавал автор
  - Это финальная обрезанная версия с сервера
```

---

## Что хранится где?

### В БРАУЗЕРЕ (клиент):
```javascript
MediaItem {
  id: "media-1",
  url: "http://server.com/storage/original-image.jpg",  // ОРИГИНАЛ
  transform: {
    cropRect: { x: 100, y: 50, w: 800, h: 600 }  // Координаты
  },
  croppedPreviewUrl: "blob:http://localhost:3000/abc-123"  // ПРЕВЬЮ (временное!)
}
```

- `url` - ссылка на ОРИГИНАЛ на сервере
- `cropRect` - координаты обрезки (числа)
- `croppedPreviewUrl` - временное превью в памяти браузера (НЕ отправляется!)

### НА СЕРВЕРЕ (при публикации):

**Запрос от клиента:**
```json
{
  "media": [
    {
      "url": "http://server.com/storage/original-image.jpg",
      "crop_rect": { "x": 100, "y": 50, "w": 800, "h": 600 }
    }
  ]
}
```

**Сервер обрабатывает:**
1. Читает оригинал: `storage/original-image.jpg`
2. Применяет координаты обрезки
3. Сохраняет результат: `storage/cropped-abc123.jpg`

**В БД сохраняется:**
```json
{
  "post_id": "post-123",
  "media_url": "http://server.com/storage/cropped-abc123.jpg"  // Обрезанное!
}
```

---

## Визуальная диаграмма:

```
КЛИЕНТ                                  СЕРВЕР
─────────────────────────────────────────────────────────────

📁 Original.jpg (3000x2000)
   ↓
   │ Upload
   ├──────────────────────────────────→ 💾 storage/original.jpg
   │                                       (сохранен оригинал)
   │
   │ ← URL: /storage/original.jpg ─────┘
   │
   ↓
🖼️ Показ оригинала

👤 Пользователь обрезает
   ↓
📐 Координаты: {x:100, y:50, w:800, h:600}
   ↓
🎨 Canvas создает превью
   ↓ (локально!)
🖼️ blob:localhost/abc-123
   (существует только в браузере)
   ↓
🖼️ Показ превью в окне


👤 Нажимает "Post"
   ↓
   │ Отправка:
   │ - URL: /storage/original.jpg
   │ - Координаты: {x:100, y:50, w:800, h:600}
   │
   ├──────────────────────────────────→ 📥 Получен запрос
   │                                       ↓
   │                                    📁 Читает original.jpg
   │                                       ↓
   │                                    ✂️ Обрезает по координатам
   │                                       ↓
   │                                    💾 storage/cropped.jpg
   │                                       (сохранено обрезанное)
   │                                       ↓
   │                                    🗄️ БД: media_url = cropped.jpg
   │
   │ ← Пост создан ────────────────────┘
   ↓
✅ Готово!

🗑️ blob:localhost/abc-123
   (автоматически удален)
```

---

## Ключевые моменты:

### ❌ Превью НЕ отправляется на сервер
- Blob URL существует ТОЛЬКО в памяти браузера
- Это временное изображение для показа пользователю
- При закрытии окна - автоматически удаляется

### ✅ На сервер отправляется:
1. **URL оригинального изображения** (который уже на сервере)
2. **Координаты обрезки** (просто 4 числа: x, y, width, height)

### ✅ Сервер создает финальное изображение:
- Берет оригинал из storage
- Применяет координаты обрезки
- Сохраняет обрезанную версию
- Это финальное изображение видят все пользователи

---

## Пример реальных данных:

### Что видит пользователь в браузере:

```javascript
// После обрезки, до публикации:
{
  url: "http://mysite.com/uploads/photo-original-456.jpg",
  croppedPreviewUrl: "blob:http://localhost:3000/550e8400-e29b",
  transform: {
    cropRect: { x: 200, y: 150, w: 1200, h: 900 }
  }
}

// croppedPreviewUrl - показывается пользователю в превью
// но НЕ отправляется на сервер!
```

### Что отправляется на сервер:

```json
{
  "content": "Мой пост!",
  "media": [
    {
      "media_id": "456",
      "crop_x": 200,
      "crop_y": 150,
      "crop_width": 1200,
      "crop_height": 900
    }
  ]
}
```

### Что делает сервер:

```go
// Псевдокод обработки на сервере
func ProcessPost(req PostRequest) {
    // 1. Получаем оригинал
    originalImage := storage.Get("photo-original-456.jpg")
    
    // 2. Обрезаем по координатам
    croppedImage := crop(originalImage, 
        x: req.crop_x,
        y: req.crop_y, 
        w: req.crop_width,
        h: req.crop_height
    )
    
    // 3. Сохраняем обрезанное
    newURL := storage.Save(croppedImage, "photo-cropped-789.jpg")
    
    // 4. Создаем пост с новым URL
    post := CreatePost(
        content: req.content,
        media_url: newURL  // "photo-cropped-789.jpg"
    )
    
    // 5. Опционально: удаляем оригинал
    storage.Delete("photo-original-456.jpg")
}
```

---

## Почему так сделано?

### 👍 Преимущества текущего подхода:

1. **Качество изображения:**
   - Сервер обрабатывает оригинал в полном качестве
   - Нет потери качества при конвертации blob → upload

2. **Размер передачи:**
   - Не нужно загружать обрезанное превью на сервер
   - Отправляются только 4 числа (координаты)
   - Экономия трафика!

3. **Безопасность:**
   - Сервер контролирует финальную обработку
   - Можно добавить дополнительные проверки
   - Можно оптимизировать размер/качество

4. **Гибкость:**
   - Можно позже изменить способ обработки на сервере
   - Можно создавать разные размеры (thumbnail, medium, large)
   - Клиент просто передает координаты

---

## Альтернативный подход (если отправлять blob):

### ❌ Если бы отправляли blob на сервер:

```
Пользователь обрезает
    ↓
Canvas создает превью
    ↓
blob:localhost/abc → преобразовать в File
    ↓
Upload обрезанного файла на сервер (10MB трафика!)
    ↓
Сервер сохраняет
```

**Проблемы:**
- ❌ Двойная загрузка (оригинал + обрезанное)
- ❌ Больше трафика
- ❌ Потеря качества при blob→File→upload
- ❌ Дольше загружается

---

## Резюме:

### Что происходит на самом деле:

```
┌─────────────────┐
│ КЛИЕНТ          │
│                 │
│ 1. Загружает    │───→ ОРИГИНАЛ ───→ ┌─────────────────┐
│    оригинал     │                    │ СЕРВЕР          │
│                 │                    │                 │
│ 2. Обрезает     │                    │ Сохраняет       │
│    (локально)   │                    │ ОРИГИНАЛ        │
│                 │                    │                 │
│ 3. Показывает   │                    └─────────────────┘
│    превью       │
│    (blob URL)   │
│                 │
│ 4. Публикует    │───→ КООРДИНАТЫ ──→ ┌─────────────────┐
│    пост         │         {x,y,w,h}  │ СЕРВЕР          │
│                 │                    │                 │
│                 │                    │ 1. Берет        │
│                 │                    │    ОРИГИНАЛ     │
│                 │                    │ 2. Обрезает     │
│                 │                    │ 3. Сохраняет    │
│                 │                    │    ФИНАЛ        │
│                 │                    │                 │
│ 5. Удаляет      │                    └─────────────────┘
│    превью       │
│    (blob)       │
│                 │
└─────────────────┘
```

### В базе данных хранится:
- ✅ URL финального обрезанного изображения (с сервера)
- ❌ НЕ blob URL (он временный, только в браузере)

### Пользователи видят:
- ✅ Финальное обрезанное изображение (обработанное сервером)
- ❌ НЕ превью из браузера автора

---

*Последнее обновление: 27.10.2025*
